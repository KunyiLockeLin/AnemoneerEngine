#pragma once
//This file is generated by code_generator.cpp.DO NOT edit this file.
#include "common/common.h"

using ID = int;

enum AeResult {
    AE_SUCCESS = 0,
    AE_ERROR_UNKNOWN = 1,
};

static inline const char* string_AeResult(AeResult type) {
    switch (type) {
        CASE_STR(AE_SUCCESS);
        CASE_STR(AE_ERROR_UNKNOWN);
        default:
            ASSERT(0,"AE_INVALID");
    }
}

enum AE_GAMEOBJECT_TYPE {
    eGAMEOBJECT_Scene = 2000,
    eGAMEOBJECT_Object = 1000,
    eGAMEOBJECT_Component_Transform = 1,
    eGAMEOBJECT_Component_Camera = 2,
    eGAMEOBJECT_Component_PostProcessing = 3,
    eGAMEOBJECT_Component_Light = 4,
    eGAMEOBJECT_Component_Line = 5,
    eGAMEOBJECT_Component_Model = 6,
    eGAMEOBJECT_Component_Animation = 7,
    eGAMEOBJECT_Component_Plane = 8,
    eGAMEOBJECT_Component_Cubemap = 9,
    eGAMEOBJECT_Component_Particle = 10,
    eGAMEOBJECT_Component_Material = 11,
    eGAMEOBJECT_Component_InputControl = 12,
    eGAMEOBJECT_Component_Axis = 13,
    eGAMEOBJECT_Component_Grid = 14,
    eGAMEOBJECT_Component_RenderSetting = 15,
};

static inline const char* string_AE_GAMEOBJECT_TYPE(AE_GAMEOBJECT_TYPE type) {
    switch (type) {
        CASE_STR(eGAMEOBJECT_Scene);
        CASE_STR(eGAMEOBJECT_Object);
        CASE_STR(eGAMEOBJECT_Component_Transform);
        CASE_STR(eGAMEOBJECT_Component_Camera);
        CASE_STR(eGAMEOBJECT_Component_PostProcessing);
        CASE_STR(eGAMEOBJECT_Component_Light);
        CASE_STR(eGAMEOBJECT_Component_Line);
        CASE_STR(eGAMEOBJECT_Component_Model);
        CASE_STR(eGAMEOBJECT_Component_Animation);
        CASE_STR(eGAMEOBJECT_Component_Plane);
        CASE_STR(eGAMEOBJECT_Component_Cubemap);
        CASE_STR(eGAMEOBJECT_Component_Particle);
        CASE_STR(eGAMEOBJECT_Component_Material);
        CASE_STR(eGAMEOBJECT_Component_InputControl);
        CASE_STR(eGAMEOBJECT_Component_Axis);
        CASE_STR(eGAMEOBJECT_Component_Grid);
        CASE_STR(eGAMEOBJECT_Component_RenderSetting);
        default:
            ASSERT(0,"eGAMEOBJECT_INVALID");
    }
}

enum AE_RENDER_TYPE {
    eRENDER_KHR = 0,
    eRENDER_UI = 1,
    eRENDER_Main = 2,
    eRENDER_Color = 3,
    eRENDER_MAX = 4,
};

static inline const char* string_AE_RENDER_TYPE(AE_RENDER_TYPE type) {
    switch (type) {
        CASE_STR(eRENDER_KHR);
        CASE_STR(eRENDER_UI);
        CASE_STR(eRENDER_Main);
        CASE_STR(eRENDER_Color);
        CASE_STR(eRENDER_MAX);
        default:
            ASSERT(0,"eRENDER_INVALID");
    }
}

enum AE_LIGHT_TYPE {
    eLIGHT_Point = 0,
    eLIGHT_Direction = 1,
    eLIGHT_Spot = 2,
};

static inline const char* string_AE_LIGHT_TYPE(AE_LIGHT_TYPE type) {
    switch (type) {
        CASE_STR(eLIGHT_Point);
        CASE_STR(eLIGHT_Direction);
        CASE_STR(eLIGHT_Spot);
        default:
            ASSERT(0,"eLIGHT_INVALID");
    }
}

enum AE_ACTION_STATE {
    eACTION_Stop = 0,
    eACTION_Play = 1,
    eACTION_Pause = 2,
};

static inline const char* string_AE_ACTION_STATE(AE_ACTION_STATE type) {
    switch (type) {
        CASE_STR(eACTION_Stop);
        CASE_STR(eACTION_Play);
        CASE_STR(eACTION_Pause);
        default:
            ASSERT(0,"eACTION_INVALID");
    }
}

enum AE_ACTION_PLAY_TYPE {
    eACTION_PLAY_Once = 0,
    eACTION_PLAY_Replay = 1,
    eACTION_PLAY_Next = 2,
};

static inline const char* string_AE_ACTION_PLAY_TYPE(AE_ACTION_PLAY_TYPE type) {
    switch (type) {
        CASE_STR(eACTION_PLAY_Once);
        CASE_STR(eACTION_PLAY_Replay);
        CASE_STR(eACTION_PLAY_Next);
        default:
            ASSERT(0,"eACTION_PLAY_INVALID");
    }
}

enum AE_PLANE_TYPE {
    ePLANE_D3D = 0,
    ePLANE_Billboard = 1,
    ePLANE_D2D = 2,
};

static inline const char* string_AE_PLANE_TYPE(AE_PLANE_TYPE type) {
    switch (type) {
        CASE_STR(ePLANE_D3D);
        CASE_STR(ePLANE_Billboard);
        CASE_STR(ePLANE_D2D);
        default:
            ASSERT(0,"ePLANE_INVALID");
    }
}

enum AE_ALIGN_TYPE {
    eALIGN_Top_Left = 0,
    eALIGN_Top_Middle = 1,
    eALIGN_Top_Right = 2,
    eALIGN_Middle_Left = 3,
    eALIGN_Middle_Middle = 4,
    eALIGN_Middle_Right = 5,
    eALIGN_Bottom_Left = 6,
    eALIGN_Bottom_Middle = 7,
    eALIGN_Bottom_Right = 8,
};

static inline const char* string_AE_ALIGN_TYPE(AE_ALIGN_TYPE type) {
    switch (type) {
        CASE_STR(eALIGN_Top_Left);
        CASE_STR(eALIGN_Top_Middle);
        CASE_STR(eALIGN_Top_Right);
        CASE_STR(eALIGN_Middle_Left);
        CASE_STR(eALIGN_Middle_Middle);
        CASE_STR(eALIGN_Middle_Right);
        CASE_STR(eALIGN_Bottom_Left);
        CASE_STR(eALIGN_Bottom_Middle);
        CASE_STR(eALIGN_Bottom_Right);
        default:
            ASSERT(0,"eALIGN_INVALID");
    }
}

struct AeBaseData {
    std::string name;
    AE_GAMEOBJECT_TYPE type;
    ID oid;
    ID eid;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        name = property_->data->key;
        type = property_->getXMLValue<AE_GAMEOBJECT_TYPE>("type");
        oid = property_->getXMLValue<ID>("oid");
        eid = property_->getXMLValue<ID>("eid");
    }
    void reset() { read(*property_); }
};

struct AeUIBaseData {
    AeArray<int, 2> position;
    AeArray<int, 2> size;
    AE_ALIGN_TYPE alignType;
    ID font_oid;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        position = property_->getXMLValues<int, 2>("position");
        size = property_->getXMLValues<int, 2>("size");
        alignType = property_->getXMLValue<AE_ALIGN_TYPE>("alignType");
        font_oid = property_->getXMLValue<ID>("font_oid");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentTransform {
    AeArray<float, 3> position;
    AeArray<float, 3> scale;
    AeArray<float, 3> faceEular;
    AeArray<float, 3> rotateSpeed;
    AeArray<float, 3> revoluteSpeed;
    AeArray<bool, 3> revoluteFixAxis;
    ID targetAnimationOID;
    std::string targetBoneName;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        position = property_->getXMLValues<float, 3>("position");
        scale = property_->getXMLValues<float, 3>("scale");
        faceEular = property_->getXMLValues<float, 3>("faceEular");
        rotateSpeed = property_->getXMLValues<float, 3>("rotateSpeed");
        revoluteSpeed = property_->getXMLValues<float, 3>("revoluteSpeed");
        revoluteFixAxis = property_->getXMLValues<bool, 3>("revoluteFixAxis");
        targetAnimationOID = property_->getXMLValue<ID>("targetAnimationOID");
        targetBoneName = property_->getXMLValue<std::string>("targetBoneName");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentCamera {
    AE_RENDER_TYPE renderType;
    AeArray<int, 2> renderSize;
    ID lookAtTransformOID;
    AeArray<float, 3> up;
    float fov;
    float fnear;
    float ffar;
    float aperture;
    float speed;
    float cullingDistance;
    int raytracingDepth;
    ID postProcessingOID;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        renderType = property_->getXMLValue<AE_RENDER_TYPE>("renderType");
        renderSize = property_->getXMLValues<int, 2>("renderSize");
        lookAtTransformOID = property_->getXMLValue<ID>("lookAtTransformOID");
        up = property_->getXMLValues<float, 3>("up");
        fov = property_->getXMLValue<float>("fov");
        fnear = property_->getXMLValue<float>("fnear");
        ffar = property_->getXMLValue<float>("ffar");
        aperture = property_->getXMLValue<float>("aperture");
        speed = property_->getXMLValue<float>("speed");
        cullingDistance = property_->getXMLValue<float>("cullingDistance");
        raytracingDepth = property_->getXMLValue<int>("raytracingDepth");
        postProcessingOID = property_->getXMLValue<ID>("postProcessingOID");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentPostProcessing {
    std::string vert;
    std::string tesc;
    std::string tese;
    std::string geom;
    std::string frag;
    AeArray<float, 4> param;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        vert = property_->getXMLValue<std::string>("vert");
        tesc = property_->getXMLValue<std::string>("tesc");
        tese = property_->getXMLValue<std::string>("tese");
        geom = property_->getXMLValue<std::string>("geom");
        frag = property_->getXMLValue<std::string>("frag");
        param = property_->getXMLValues<float, 4>("param");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentLight {
    AE_LIGHT_TYPE lightType;
    AeArray<float, 3> color;
    float intensity;
    float coneAngle;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        lightType = property_->getXMLValue<AE_LIGHT_TYPE>("lightType");
        color = property_->getXMLValues<float, 3>("color");
        intensity = property_->getXMLValue<float>("intensity");
        coneAngle = property_->getXMLValue<float>("coneAngle");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentLine {
    ID targetTransformOID;
    AeArray<float, 3> color;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        targetTransformOID = property_->getXMLValue<ID>("targetTransformOID");
        color = property_->getXMLValues<float, 3>("color");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentModel {
    std::string obj;
    float outlineWidth;
    ID materialOID;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        obj = property_->getXMLValue<std::string>("obj");
        outlineWidth = property_->getXMLValue<float>("outlineWidth");
        materialOID = property_->getXMLValue<ID>("materialOID");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentAnimation {
    std::string obj;
    float outlineWidth;
    AE_ACTION_STATE actionState;
    float actionSpeed;
    int actionID;
    AE_ACTION_PLAY_TYPE actionPlayType;
    ID materialOID;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        obj = property_->getXMLValue<std::string>("obj");
        outlineWidth = property_->getXMLValue<float>("outlineWidth");
        actionState = property_->getXMLValue<AE_ACTION_STATE>("actionState");
        actionSpeed = property_->getXMLValue<float>("actionSpeed");
        actionID = property_->getXMLValue<int>("actionID");
        actionPlayType = property_->getXMLValue<AE_ACTION_PLAY_TYPE>("actionPlayType");
        materialOID = property_->getXMLValue<ID>("materialOID");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentPlane {
    AE_PLANE_TYPE planeType;
    ID materialOID;
    ID targetCameraOID;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        planeType = property_->getXMLValue<AE_PLANE_TYPE>("planeType");
        materialOID = property_->getXMLValue<ID>("materialOID");
        targetCameraOID = property_->getXMLValue<ID>("targetCameraOID");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentCubemap {
    std::string image;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        image = property_->getXMLValue<std::string>("image");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentParticle {
    std::string image;
    bool alpha;
    bool reborn;
    ID bornTargetTranformOID;
    int count_once;
    int count_period;
    int count_total;
    int count_range;
    int life_second;
    int life_range;
    AeArray<float, 3> init_pos_volume;
    AeArray<float, 3> init_pos_volume_range;
    float init_pos_radius;
    float init_pos_radius_range;
    float init_pos_degree;
    float init_pos_degree_range;
    AeArray<float, 3> init_speed;
    AeArray<float, 3> init_speed_range;
    AeArray<float, 3> force;
    AeArray<float, 3> force_range;
    AeArray<float, 2> size;
    AeArray<float, 2> size_range;
    AeArray<float, 3> color;
    AeArray<float, 3> color_range;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        image = property_->getXMLValue<std::string>("image");
        alpha = property_->getXMLValue<bool>("alpha");
        reborn = property_->getXMLValue<bool>("reborn");
        bornTargetTranformOID = property_->getXMLValue<ID>("bornTargetTranformOID");
        count_once = property_->getXMLValue<int>("count_once");
        count_period = property_->getXMLValue<int>("count_period");
        count_total = property_->getXMLValue<int>("count_total");
        count_range = property_->getXMLValue<int>("count_range");
        life_second = property_->getXMLValue<int>("life_second");
        life_range = property_->getXMLValue<int>("life_range");
        init_pos_volume = property_->getXMLValues<float, 3>("init_pos_volume");
        init_pos_volume_range = property_->getXMLValues<float, 3>("init_pos_volume_range");
        init_pos_radius = property_->getXMLValue<float>("init_pos_radius");
        init_pos_radius_range = property_->getXMLValue<float>("init_pos_radius_range");
        init_pos_degree = property_->getXMLValue<float>("init_pos_degree");
        init_pos_degree_range = property_->getXMLValue<float>("init_pos_degree_range");
        init_speed = property_->getXMLValues<float, 3>("init_speed");
        init_speed_range = property_->getXMLValues<float, 3>("init_speed_range");
        force = property_->getXMLValues<float, 3>("force");
        force_range = property_->getXMLValues<float, 3>("force_range");
        size = property_->getXMLValues<float, 2>("size");
        size_range = property_->getXMLValues<float, 2>("size_range");
        color = property_->getXMLValues<float, 3>("color");
        color_range = property_->getXMLValues<float, 3>("color_range");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentMaterial {
    std::string vert;
    std::string tesc;
    std::string tese;
    std::string geom;
    std::string frag;
    bool alpha;
    AeArray<float, 4> baseColor;
    float baseValueRate;
    float metallic;
    float roughness;
    float emissive;
    std::string baseMap;
    std::string cubeMap;
    std::string normalMap;
    std::string metallicRoughnessMap;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        vert = property_->getXMLValue<std::string>("vert");
        tesc = property_->getXMLValue<std::string>("tesc");
        tese = property_->getXMLValue<std::string>("tese");
        geom = property_->getXMLValue<std::string>("geom");
        frag = property_->getXMLValue<std::string>("frag");
        alpha = property_->getXMLValue<bool>("alpha");
        baseColor = property_->getXMLValues<float, 4>("baseColor");
        baseValueRate = property_->getXMLValue<float>("baseValueRate");
        metallic = property_->getXMLValue<float>("metallic");
        roughness = property_->getXMLValue<float>("roughness");
        emissive = property_->getXMLValue<float>("emissive");
        baseMap = property_->getXMLValue<std::string>("baseMap");
        cubeMap = property_->getXMLValue<std::string>("cubeMap");
        normalMap = property_->getXMLValue<std::string>("normalMap");
        metallicRoughnessMap = property_->getXMLValue<std::string>("metallicRoughnessMap");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentInputControl {

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentAxis {

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentGrid {
    int column;
    int row;
    AeArray<float, 3> color;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        column = property_->getXMLValue<int>("column");
        row = property_->getXMLValue<int>("row");
        color = property_->getXMLValues<float, 3>("color");
    }
    void reset() { read(*property_); }
};

struct AeGameObjectDataComponentRenderSetting {
    int FPS;
    bool normal;
    bool mesh;
    int msaa;
    float gamma;
    float exposure;
    float lineWidth;
    AeArray<float, 4> clearColor;

    AeXMLNode* property_;
    void read(AeXMLNode& node) {
        property_ = &node;
        FPS = property_->getXMLValue<int>("FPS");
        normal = property_->getXMLValue<bool>("normal");
        mesh = property_->getXMLValue<bool>("mesh");
        msaa = property_->getXMLValue<int>("msaa");
        gamma = property_->getXMLValue<float>("gamma");
        exposure = property_->getXMLValue<float>("exposure");
        lineWidth = property_->getXMLValue<float>("lineWidth");
        clearColor = property_->getXMLValues<float, 4>("clearColor");
    }
    void reset() { read(*property_); }
};


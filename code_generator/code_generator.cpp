#pragma once

#include <stdio.h>
#include "common/common.h"
#include <direct.h>

const std::string indent = "    ";
const char config_path[] = "..\\..\\output\\data\\config.xml";
AeXMLNode* config = nullptr;
AeXMLNode* code_define = nullptr;
AeXMLNode* enum_define = nullptr;

struct enum_data {
    std::string key;
    std::string name;
    std::string prefix;
    std::vector<AeNode> enums;
};

void AddStrcut(AeXMLNode& node, std::string& code_string, std::string struct_name) {
    code_string += ("\nstruct " + struct_name + " {\n");
    std::vector<std::string> load_codes;

    for (auto& element : node.data->elements) {
        std::vector<std::string> types = COM_ENCODE.split<std::string>(element.value, " ");
        if (types[0].compare("enum") == 0) {
            std::string key = element.key + ".name";
            std::string enum_name = enum_define->getXMLValue<std::string>(key.c_str());
            code_string += (indent + enum_name + " " + element.key + ";\n");
            load_codes.push_back(element.key + " = property_->getXMLValue<" + enum_name + ">(\"" + element.key + "\");");
        } else {
            if (types.size() != 2) {
                if (element.key.compare("name") == 0) {
                    load_codes.push_back(element.key + " = property_->data->key;");
                } else {
                    load_codes.push_back(element.key + " = property_->getXMLValue<" + types[0] + ">(\"" + element.key + "\");");
                }
                code_string += (indent + types[0] + " " + element.key + ";\n");
            } else {
                std::string type1 = "AeArray<" + types[0] + ", " + types[1] + ">";
                load_codes.push_back(element.key + " = property_->getXMLValues<" + types[0] + ", " + types[1] + ">(\"" +
                                     element.key + "\");");
                code_string += (indent + type1 + " " + element.key + ";\n");
            }
        }
    }

    // read xml
    code_string += ("\n" + indent + "AeXMLNode* property_;\n");
    code_string += (indent + "void read(AeXMLNode& node) {\n");
    code_string += (indent + indent + "property_ = &node;\n");
    for (auto& load_code : load_codes) {
        code_string += (indent + indent + load_code + "\n");
    }
    code_string += (indent + "}\n");

    code_string += (indent + "void reset() { read(*property_); }\n");
    code_string += "};\n";
}

int main(int argc, char* argv[]) {
    // generated_config_struct_enum.h
    LOG("Create generated\\generated_config_struct_enum.h");

    std::string config_struct_enum = "";
    config_struct_enum +=
        "#pragma once\n"
        "//This file is generated by code_generator.cpp. DO NOT edit this file.\n"
        "#include \"common/common.h\"\n";
        // "#include <cstring>";

    config = COM_MGR.getXML(config_path);
    code_define = config->getXMLNode("code_define");
    enum_define = code_define->getXMLNode("enum");

    // using
    config_struct_enum += "\n";
    auto nodes = code_define->getXMLNode("using");
    for (auto* node: nodes->data->nexts) {
        config_struct_enum += ("using " + node->data->key + " = " + node->getXMLValue<const char*>("type") + ";\n");
    }

    // enum
    std::vector<enum_data> enum_datas;
    for (auto node : enum_define->data->nexts) {
        enum_data e_data;
        e_data.key = node->data->key;

        for (auto e : node->data->elements) {
            if (e.key.compare("name") == 0) {
                e_data.name = e.value;
            } else if (e.key.compare("prefix") == 0) {
                e_data.prefix = e.value;
            } else {
                e_data.enums.push_back(e);
            }
        }

        if (e_data.key.compare("type") == 0) {
            auto* node = config->getXMLNode("scenes.default");
            e_data.enums.push_back({"Scene", node->getXMLValue<const char*>("type")});

            node = config->getXMLNode("objects.default");
            e_data.enums.push_back({"Object", node->getXMLValue<const char*>("type")});

            node = config->getXMLNode("components");
            std::string key = "Component_";
            for (auto comp : node->data->nexts) {
                auto* node2 = comp->getXMLNode("default");
                e_data.enums.push_back({key + comp->data->key, node2->getXMLValue<const char*>("type")});
            }
        }
        enum_datas.push_back(e_data);
    }
    for (auto e_data : enum_datas) {
        config_struct_enum += ("\nenum " + e_data.name + " {\n");
        for (auto e : e_data.enums) {
            config_struct_enum += (indent + e_data.prefix + e.key + " = " + e.value + ",\n");
        }
        config_struct_enum += ("};\n");
        config_struct_enum += ("\nstatic inline const char* string_" + e_data.name + "(" + e_data.name + " type) {\n");
        config_struct_enum += (indent + "switch (type) {\n");

        for (auto e : e_data.enums) {
            config_struct_enum += (indent + indent + "CASE_STR(" + e_data.prefix + e.key + ");\n");
        }
        config_struct_enum += (indent + indent + "default:\n");
        config_struct_enum += (indent + indent + indent + "ASSERT(0,\"" + e_data.prefix + "INVALID\");\n");
        config_struct_enum += (indent + "}\n");
        //config_struct_enum += (indent + "return \"" + e_data.prefix + "INVALID\";\n");
        config_struct_enum += "}\n";
    }

    // struct
    nodes = code_define->getXMLNode("struct");
    for (auto* node : nodes->data->nexts) {
        AddStrcut(*node, config_struct_enum, node->data->key);
    }

    nodes = config->getXMLNode("components");
    for (auto node : nodes->data->nexts) {
        std::string struct_name = "AeGameObjectDataComponent";
        struct_name += node->data->key;
        AddStrcut(*node->getXMLNode("define"), config_struct_enum, struct_name);
    }

    AeFile file;
    file.open("..\\..\\code_generator\\generated_config_struct_enum.h");
    file.addNewLine(config_struct_enum.c_str());
    file.close();
    LOG("CodeGenerator End.");
    return 0;
}
